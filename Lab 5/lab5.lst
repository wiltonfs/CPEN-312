                 -1   $modde0cv
0000              1   ;  MODDDE2: Register definition for DE2-8052 softcore
0000              2   ;
0000              3   ;   Copyright (C) 2011  Jesus Calvino-Fraga, jesusc at ece.ubc.ca
0000              4   ;
0000              5   ;   This library is free software; you can redistribute it and/or
0000              6   ;   modify it under the terms of the GNU Lesser General Public
0000              7   ;   License as published by the Free Software Foundation; either
0000              8   ;   version 2.1 of the License, or (at your option) any later version.
0000              9   ;
0000             10   ;   This library is distributed in the hope that it will be useful,
0000             11   ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
0000             12   ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
0000             13   ;   Lesser General Public License for more details.
0000             14   ;
0000             15   ;   You should have received a copy of the GNU Lesser General Public
0000             16   ;   License along with this library; if not, write to the Free Software
0000             17   ;   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
0000             18   ;
0000             19       
0000             20   P0     DATA  080H  ;PORT 0
0000             21   SP     DATA  081H  ;STACK POINTER
0000             22   DPL    DATA  082H  ;DATA POINTER 0 - LOW BYTE
0000             23   DPH    DATA  083H  ;DATA POINTER 0 - HIGH BYTE
0000             24   DPL1   DATA  084H  ;DATA POINTER 1 - LOW BYTE
0000             25   DPH1   DATA  085H  ;DATA POINTER 1 - HIGH BYTE
0000             26   DPS    DATA  086H  ;DATA POINTER SELECT. DPH1, DPL1 active when DPS.0=1
0000             27   PCON   DATA  087H  ;POWER CONTROL
0000             28   TCON   DATA  088H  ;TIMER CONTROL
0000             29   TMOD   DATA  089H  ;TIMER MODE
0000             30   TL0    DATA  08AH  ;TIMER 0 - LOW BYTE
0000             31   TL1    DATA  08BH  ;TIMER 1 - LOW BYTE
0000             32   TH0    DATA  08CH  ;TIMER 0 - HIGH BYTE
0000             33   TH1    DATA  08DH  ;TIMER 1 - HIGH BYTE
0000             34   P1     DATA  090H  ;PORT 1
0000             35   SCON   DATA  098H  ;SERIAL PORT CONTROL
0000             36   SBUF   DATA  099H  ;SERIAL PORT BUFFER
0000             37   P2     DATA  0A0H  ;PORT 2
0000             38   IE     DATA  0A8H  ;INTERRUPT ENABLE
0000             39   P3     DATA  0B0H  ;PORT 3
0000             40   IP     DATA  0B8H  ;INTERRUPT PRIORITY
0000             41   T2CON  DATA  0C8H  ;TIMER 2 CONTROL
0000             42   T2MOD  DATA  0C9H  ;TIMER 2 MODE
0000             43   RCAP2L DATA  0CAH  ;TIMER 2 CAPTURE REGISTER - LOW BYTE
0000             44   RCAP2H DATA  0CBH  ;TIMER 2 CAPTURE REGISTER - HIGH BYTE
0000             45   TL2    DATA  0CCH  ;TIMER 2 - LOW BYTE
0000             46   TH2    DATA  0CDH  ;TIMER 2 - HIGH BYTE
0000             47   PSW    DATA  0D0H  ;PROGRAM STATUS WORD
0000             48   ACC    DATA  0E0H  ;ACCUMULATOR
0000             49   B      DATA  0F0H  ;MULTIPLICATION REGISTER
0000             50   IT0    BIT   088H  ;TCON.0 - EXT. INTERRUPT 0 TYPE
0000             51   IE0    BIT   089H  ;TCON.1 - EXT. INTERRUPT 0 EDGE FLAG
0000             52   IT1    BIT   08AH  ;TCON.2 - EXT. INTERRUPT 1 TYPE
0000             53   IE1    BIT   08BH  ;TCON.3 - EXT. INTERRUPT 1 EDGE FLAG
0000             54   TR0    BIT   08CH  ;TCON.4 - TIMER 0 ON/OFF CONTROL
0000             55   TF0    BIT   08DH  ;TCON.5 - TIMER 0 OVERFLOW FLAG
0000             56   TR1    BIT   08EH  ;TCON.6 - TIMER 1 ON/OFF CONTROL
0000             57   TF1    BIT   08FH  ;TCON.7 - TIMER 1 OVERFLOW FLAG
0000             58   RI     BIT   098H  ;SCON.0 - RECEIVE INTERRUPT FLAG
0000             59   TI     BIT   099H  ;SCON.1 - TRANSMIT INTERRUPT FLAG
0000             60   RB8    BIT   09AH  ;SCON.2 - RECEIVE BIT 8
0000             61   TB8    BIT   09BH  ;SCON.3 - TRANSMIT BIT 8
0000             62   REN    BIT   09CH  ;SCON.4 - RECEIVE ENABLE
0000             63   SM2    BIT   09DH  ;SCON.5 - SERIAL MODE CONTROL BIT 2
0000             64   SM1    BIT   09EH  ;SCON.6 - SERIAL MODE CONTROL BIT 1
0000             65   SM0    BIT   09FH  ;SCON.7 - SERIAL MODE CONTROL BIT 0
0000             66   EX0    BIT   0A8H  ;IE.0 - EXTERNAL INTERRUPT 0 ENABLE
0000             67   ET0    BIT   0A9H  ;IE.1 - TIMER 0 INTERRUPT ENABLE
0000             68   EX1    BIT   0AAH  ;IE.2 - EXTERNAL INTERRUPT 1 ENABLE
0000             69   ET1    BIT   0ABH  ;IE.3 - TIMER 1 INTERRUPT ENABLE
0000             70   ES     BIT   0ACH  ;IE.4 - SERIAL PORT INTERRUPT ENABLE
0000             71   ET2    BIT   0ADH  ;IE.5 - TIMER 2 INTERRUPT ENABLE
0000             72   EA     BIT   0AFH  ;IE.7 - GLOBAL INTERRUPT ENABLE
0000             73   RXD    BIT   0B0H  ;P3.0 - SERIAL PORT RECEIVE INPUT
0000             74   TXD    BIT   0B1H  ;P3.1 - SERIAL PORT TRANSMIT OUTPUT
0000             75   INT0   BIT   0B2H  ;P3.2 - EXTERNAL INTERRUPT 0 INPUT
0000             76   INT1   BIT   0B3H  ;P3.3 - EXTERNAL INTERRUPT 1 INPUT
0000             77   T0     BIT   0B4H  ;P3.4 - TIMER 0 COUNT INPUT
0000             78   T1     BIT   0B5H  ;P3.5 - TIMER 1 COUNT INPUT
0000             79   WR     BIT   0B6H  ;P3.6 - WRITE CONTROL FOR EXT. MEMORY
0000             80   RD     BIT   0B7H  ;P3.7 - READ CONTROL FOR EXT. MEMORY
0000             81   PX0    BIT   0B8H  ;IP.0 - EXTERNAL INTERRUPT 0 PRIORITY
0000             82   PT0    BIT   0B9H  ;IP.1 - TIMER 0 PRIORITY
0000             83   PX1    BIT   0BAH  ;IP.2 - EXTERNAL INTERRUPT 1 PRIORITY
0000             84   PT1    BIT   0BBH  ;IP.3 - TIMER 1 PRIORITY
0000             85   PS     BIT   0BCH  ;IP.4 - SERIAL PORT PRIORITY
0000             86   PT2    BIT   0BDH  ;IP.5 - TIMER 2 PRIORITY
0000             87   CAP2   BIT   0C8H  ;T2CON.0 - CAPTURE OR RELOAD SELECT
0000             88   CNT2   BIT   0C9H  ;T2CON.1 - TIMER OR COUNTER SELECT
0000             89   TR2    BIT   0CAH  ;T2CON.2 - TIMER 2 ON/OFF CONTROL
0000             90   EXEN2  BIT   0CBH  ;T2CON.3 - TIMER 2 EXTERNAL ENABLE FLAG
0000             91   TCLK   BIT   0CCH  ;T2CON.4 - TRANSMIT CLOCK SELECT
0000             92   RCLK   BIT   0CDH  ;T2CON.5 - RECEIVE CLOCK SELECTT
0000             93   EXF2   BIT   0CEH  ;T2CON.6 - EXTERNAL TRANSITION FLAG
0000             94   TF2    BIT   0CFH  ;T2CON.7 - TIMER 2 OVERFLOW FLAG
0000             95   P      BIT   0D0H  ;PSW.0 - ACCUMULATOR PARITY FLAG
0000             96   OV     BIT   0D2H  ;PSW.2 - OVERFLOW FLAG
0000             97   RS0    BIT   0D3H  ;PSW.3 - REGISTER BANK SELECT 0
0000             98   RS1    BIT   0D4H  ;PSW.4 - REGISTER BANK SELECT 1
0000             99   F0     BIT   0D5H  ;PSW.5 - FLAG 0
0000            100   AC     BIT   0D6H  ;PSW.6 - AUXILIARY CARRY FLAG
0000            101   CY     BIT   0D7H  ;PSW.7 - CARRY FLAG
0000            102   
0000            103   ; For the altera DE2 configured with an 8051/8052 softcore processor
0000            104   ; we have the following extra registers:
0000            105   
0000            106   HEX0   DATA  091H ; Zero turns the segment on
0000            107   HEX1   DATA  092H ; 
0000            108   HEX2   DATA  093H ; 
0000            109   HEX3   DATA  094H ; 
0000            110   HEX4   DATA  08EH ;
0000            111   HEX5   DATA  08FH ;
0000            112   HEX6   DATA  096H ;
0000            113   HEX7   DATA  097H ;
0000            114   
0000            115   P0MOD  DATA  09AH ; Input/output mode bits for port 0.  '1' sets the port to output mode.
0000            116   P1MOD  DATA  09BH ; Input/output mode bits for port 1
0000            117   P2MOD  DATA  09CH ; Input/output mode bits for port 2
0000            118   P3MOD  DATA  09DH ; Input/output mode bits for port 3
0000            119   
0000            120   LEDRA  DATA  0E8H ; LEDs LEDR0 to LEDR7 (bit addressable, ex: LEDRA.1 for LEDR1)
0000            121   LEDRB  DATA  095H ; LEDs LEDR8 to LEDR15
0000            122   LEDRC  DATA  09EH ; LEDs LEDR16, LEDR15, and LEDG8
0000            123   LEDG   DATA  0F8H ; LEDs LEDG0 to LEDG7 (bit addressable, ex: LEDG.3 for LEDG3)
0000            124   SWA    DATA  0E8H ; Switches SW0 to SW7 (bit addressable, ex: SWA.1 for SW1)
0000            125   SWB    DATA  095H ; Switches SW8 to SW15
0000            126   SWC    DATA  09EH ; Switches SW16 and SW17
0000            127   KEY    DATA  0F8H ; KEY1=KEY.1, KEY2=KEY.2, KEY3=KEY.3.  KEY0 is the reset button! 
0000            128   
0000            129   LCD_CMD   DATA 0D8H ;
0000            130   LCD_DATA  DATA 0D9H ;
0000            131   LCD_MOD   DATA 0DAH ; Write 0xff to make LCD_DATA an output
0000            132   LCD_RW    BIT  0D8H ; '0' writes to LCD
0000            133   LCD_EN    BIT  0D9H ; Toggle from '1' to '0'
0000            134   LCD_RS    BIT  0DAH ; '0' for commands, '1' for data
0000            135   LCD_ON    BIT  0DBH ; Write '1' to power the LCD
0000            136   LCD_BLON  BIT  0DCH ; Write '1' to turn on back light
0000            137   
0000            138   FLASH_CMD  data 0DBH ; The control bits of the flash memory:
0000            139   ; bit 0: FL_RST_N  Set to 1 for normal operation
0000            140   ; bit 1: FL_WE_N
0000            141   ; bit 2: FL_OE_N
0000            142   ; bit 3: FL_CE_N
0000            143   FLASH_DATA data 0DCH ; 8-bit data bus of flash memory.
0000            144   FLASH_MOD  data 0DDH ; 0xff makes FLASH_DATA output.  0x00 makes FLASH_DATA input.
0000            145   FLASH_ADD0 data 0E1H ; address bits 0 to 7.
0000            146   FLASH_ADD1 data 0E2H ; address bits 8 to 15.
0000            147   FLASH_ADD2 data 0E3H ; address bits 16 to 21.
0000            148   
0000              2   
0000              3   CSEG at 0
0000 020447       4   ljmp START
0003              5   
0030              6   dseg at 30h
0030              7   x: ds 4 ; 32-bits for variable ‘x’
0034              8   y: ds 4 ; 32-bits for variable ‘y’
0038              9   z: ds 4 ; 32 bit for variable 'z'
003C             10   bcd: ds 5 ; 10-digit packed BCD (each byte stores 2 digits)
0000             11   bseg
0000             12   mf: dbit 1 ; Math functions flag
                 -1   $include(math32.asm)
                763   $LIST
03A0             14   
03A0             15   CSEG     
03A0             16            
03A0             17            ; Look-up table for 7-seg displays
03A0             18   seg_table:
03A0 C0F9A4B0    19       DB 0C0H, 0F9H, 0A4H, 0B0H, 099H        ; 0 TO 4
     99
03A5 9282F880    20       DB 092H, 082H, 0F8H, 080H, 090H        ; 4 TO 9
     90
03AA             21   
                 22   showBCD MAC
                 23   	; Display LSD
                 24       mov A, %0
                 25       anl a, #0fh
                 26       movc A, @A+dptr
                 27       mov %1, A
                 28   	; Display MSD
                 29       mov A, %0
                 30       swap a
                 31       anl a, #0fh
                 32       movc A, @A+dptr
                 33       mov %2, A
                 34   ENDMAC
03AA             35   
03AA             36   Display:
03AA 9003A0      37            mov dptr, #seg_table
03AD             38            ; Display LSD
03AD E53C        38       mov A, bcd+0
03AF 540F        38       anl a, #0fh
03B1 93          38       movc A, @A+dptr
03B2 F591        38       mov HEX0, A
03B4             38            ; Display MSD
03B4 E53C        38       mov A, bcd+0
03B6 C4          38       swap a
03B7 540F        38       anl a, #0fh
03B9 93          38       movc A, @A+dptr
03BA F592        38       mov HEX1, A
03BC             39            ; Display LSD
03BC E53D        39       mov A, bcd+1
03BE 540F        39       anl a, #0fh
03C0 93          39       movc A, @A+dptr
03C1 F593        39       mov HEX2, A
03C3             39            ; Display MSD
03C3 E53D        39       mov A, bcd+1
03C5 C4          39       swap a
03C6 540F        39       anl a, #0fh
03C8 93          39       movc A, @A+dptr
03C9 F594        39       mov HEX3, A
03CB             40            ; Display LSD
03CB E53E        40       mov A, bcd+2
03CD 540F        40       anl a, #0fh
03CF 93          40       movc A, @A+dptr
03D0 F58E        40       mov HEX4, A
03D2             40            ; Display MSD
03D2 E53E        40       mov A, bcd+2
03D4 C4          40       swap a
03D5 540F        40       anl a, #0fh
03D7 93          40       movc A, @A+dptr
03D8 F58F        40       mov HEX5, A
03DA 22          41       ret
03DB             42   
                 43   MYRLC MAC
                 44   	mov a, %0
                 45   	rlc a
                 46   	mov %0, a
                 47   ENDMAC
03DB             48   
03DB             49   Shift_Digits:
03DB 7804        50            mov R0, #4 ; shift left four bits
03DD             51   Shift_Digits_L0:
03DD C3          52            clr c
03DE E53C        53            mov a, bcd+0
03E0 33          53            rlc a
03E1 F53C        53            mov bcd+0, a
03E3 E53D        54            mov a, bcd+1
03E5 33          54            rlc a
03E6 F53D        54            mov bcd+1, a
03E8 E53E        55            mov a, bcd+2
03EA 33          55            rlc a
03EB F53E        55            mov bcd+2, a
03ED E53F        56            mov a, bcd+3
03EF 33          56            rlc a
03F0 F53F        56            mov bcd+3, a
03F2 E540        57            mov a, bcd+4
03F4 33          57            rlc a
03F5 F540        57            mov bcd+4, a
03F7 D8E4        58            djnz R0, Shift_Digits_L0
03F9             59            ; R7 has the new bcd digit      
03F9 EF          60            mov a, R7
03FA 453C        61            orl a, bcd+0
03FC F53C        62            mov bcd+0, a
03FE             63            ; bcd+3 and bcd+4 don't fit in the 7-segment displays so make them zero
03FE E4          64            clr a
03FF F540        65            mov bcd+4, a
0401 22          66            ret
0402             67   
0402             68   Wait50ms:
0402             69   ;33.33MHz, 1 clk per cycle: 0.03us
0402 781E        70            mov R0, #30
0404 794A        71   L3: mov R1, #74
0406 7AFA        72   L2: mov R2, #250
0408 DAFE        73   L1: djnz R2, L1 ;3*250*0.03us=22.5us
040A D9FA        74       djnz R1, L2 ;74*22.5us=1.665ms
040C D8F6        75       djnz R0, L3 ;1.665ms*30=50ms
040E 22          76       ret
040F             77   
040F             78   ; Check if SW0 to SW9 are toggled up.  Returns the toggled switch in
040F             79   ; R7.  If the carry is not set, no toggling switches were detected.
040F             80   ReadNumber:
040F ACE8        81            mov r4, SWA ; Read switches 0 to 7
0411 E595        82            mov a, SWB ; Read switches 8 to 9
0413 5403        83            anl a, #00000011B ; Only two bits of SWB available
0415 FD          84            mov r5, a
0416 EC          85            mov a, r4
0417 4D          86            orl a, r5
0418 602B        87            jz ReadNumber_no_number
041A 120402      88            lcall Wait50ms ; debounce
041D E5E8        89            mov a, SWA
041F C3          90            clr c
0420 9C          91            subb a, r4
0421 7022        92            jnz ReadNumber_no_number ; it was a bounce
0423 E595        93            mov a, SWB
0425 5403        94            anl a, #00000011B
0427 C3          95            clr c
0428 9D          96            subb a, r5
0429 701A        97            jnz ReadNumber_no_number ; it was a bounce
042B 7F10        98            mov r7, #16 ; Loop counter
042D             99   ReadNumber_L0:
042D C3         100            clr c
042E EC         101            mov a, r4
042F 33         102            rlc a
0430 FC         103            mov r4, a
0431 ED         104            mov a, r5
0432 33         105            rlc a
0433 FD         106            mov r5, a
0434 4004       107            jc ReadNumber_decode
0436 DFF5       108            djnz r7, ReadNumber_L0
0438 800B       109            sjmp ReadNumber_no_number       
043A            110   ReadNumber_decode:
043A 1F         111            dec r7
043B D3         112            setb c
043C            113   ReadNumber_L1:
043C E5E8       114            mov a, SWA
043E 70FC       115            jnz ReadNumber_L1
0440            116   ReadNumber_L2:
0440 E595       117            mov a, SWB
0442 70FC       118            jnz ReadNumber_L2
0444 22         119            ret
0445            120   ReadNumber_no_number:
0445 C3         121            clr c
0446 22         122            ret
0447            123            
0447            124   START: ; Called once on start
0447 75817F     125            mov SP, #7FH
044A            126            ; set everything to 0
044A E4         127            clr a
044B F5E8       128            mov LEDRA, a
044D F595       129            mov LEDRB, a
044F F53C       130            mov bcd+0, a
0451 F53D       131            mov bcd+1, a
0453 F53E       132            mov bcd+2, a
0455 F53F       133            mov bcd+3, a
0457 F540       134            mov bcd+4, a
0459 1203AA     135            lcall Display
045C            136   
045C 75F001     137            mov b, #1 ; b = 1 for addition
045F D2E8       138            setb LEDRA.0 ; Turn LEDR0 on to indicate addition
0461            139            
0461            140   LOOP: ; Called forever
0461 85F0E8     141            mov LEDRA, b                    ; Display Function select on the LEDs
0464            142   
0464            143            ; Check if number is being loaded into the calculator
0464 12040F     144            lcall ReadNumber
0467 5006       145            jnc func_button ; If nothing loaded, skip
0469 1203DB     146            lcall Shift_Digits
046C 1203AA     147            lcall Display
046F            148            
046F            149            ;This handles cycling the function
046F            150   
046F            151   func_button:     
046F 20FB14     152            jb KEY.3, load_button           ; If 'Function' key not pressed, skip
0472 30FBFD     153                    jnb KEY.3, $            ; Jumps to itself until key is relased
0475 E5F0       154                    mov a, b                        ; When the key is pressed, we double B (multiply by 2) to bitshift left one
0477 75F002     155                    mov b, #02
047A A4         156                    mul ab
047B F5F0       157                    mov b, a                        ; B is used to store the current function
047D B480E1     158                    cjne a, #10000000B, LOOP ; If B is high enough it needs to overflow back down to 1
0480 75F001     159                    mov b,          #00000001B                      ; B back down to 1
0483 020461     160                    ljmp LOOP                               ; Restart the loop
0486            161                    
0486            162            
0486            163   load_button:
0486 20FA1E     164            jb KEY.2, equal_button                  ; If 'Load' key not pressed, skip
0489 30FAFD     165                    jnb KEY.2, $            ; Jumps to itself until key is relased
048C 1200B2     166                    lcall bcd2hex           ; Convert the BCD number to hex in x
048F 120003     167                    lcall copy_xy           ; Copy x to y
0492 753000     168            mov x+0, #low (0 % 0x10000) 
0495 753100     168            mov x+1, #high(0 % 0x10000) 
0498 753200     168            mov x+2, #low (0 / 0x10000) 
049B 753300     168            mov x+3, #high(0 / 0x10000)                     ; Clear x
049E 120029     169                    lcall hex2bcd           ; Convert result in x to BCD
04A1 1203AA     170                    lcall Display           ; Display the new BCD number
04A4 020461     171                    ljmp LOOP               ; Restart the loop
04A7            172            
04A7            173   equal_button:
04A7 20F9B7     174            jb KEY.1, LOOP                  ; If 'equal' key not pressed, skip
04AA 30F9FD     175                    jnb KEY.1, $            ; Jumps to itself until key is relased
04AD 1200B2     176                    lcall bcd2hex           ; Convert the BCD number to hex in x
04B0 E5F0       177                    mov a, b        
04B2            178                    
04B2            179   ; Check for function depending on state
04B2            180   Addition:        
04B2 B40106     181            CJNE a, #00000001B, Subtraction
04B5 1200EE     182                    lcall add32     ; x = x + y
04B8 0204EE     183                    ljmp DISP_ANSWER
04BB            184                    
04BB            185   Subtraction:
04BB B40206     186            CJNE a, #00000010B, Multiplication
04BE 12010F     187                    lcall sub32     ; x = x - y
04C1 0204EE     188                    ljmp DISP_ANSWER
04C4            189                    
04C4            190   Multiplication:
04C4 B40406     191            CJNE a, #00000100B, Division
04C7 1201A3     192                    lcall mul32             ; x = x * y     
04CA 0204EE     193                    ljmp DISP_ANSWER
04CD            194                    
04CD            195   Division:
04CD B40806     196            CJNE a, #00001000B, Remainder
04D0 120337     197                    lcall div32             ; x = x / y
04D3 0204EE     198                    ljmp DISP_ANSWER
04D6            199                    
04D6            200   Remainder:       
04D6 B41006     201            CJNE a, #00010000B, Percentage
04D9 120317     202                    lcall mod32 ; x = x % y
04DC 0204EE     203                    ljmp DISP_ANSWER
04DF            204   
04DF            205   Percentage:
04DF B42006     206            CJNE a, #00100000B, Square_root                 
04E2 120324     207                    lcall perce32           ; x = (x * y) / 100
04E5 0204EE     208                    ljmp DISP_ANSWER
04E8            209                    
04E8            210   Square_root:
04E8 1202BD     211                    lcall square_root32             ; x = sqrt(x)
04EB 0204EE     212                    ljmp DISP_ANSWER
04EE            213                    
04EE            214   DISP_ANSWER:     
04EE 120029     215            lcall hex2bcd           ; Convert result in x to BCD
04F1 1203AA     216            lcall Display           ; Display the result
04F4 020461     217            ljmp LOOP               ; Go check for more input
04F7            218            
04F7            219   end
