                 -1   $MODDE0CV ; Special Function Registers declaration for CV-8052
0000              1   ;  MODDDE2: Register definition for DE2-8052 softcore
0000              2   ;
0000              3   ;   Copyright (C) 2011  Jesus Calvino-Fraga, jesusc at ece.ubc.ca
0000              4   ;
0000              5   ;   This library is free software; you can redistribute it and/or
0000              6   ;   modify it under the terms of the GNU Lesser General Public
0000              7   ;   License as published by the Free Software Foundation; either
0000              8   ;   version 2.1 of the License, or (at your option) any later version.
0000              9   ;
0000             10   ;   This library is distributed in the hope that it will be useful,
0000             11   ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
0000             12   ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
0000             13   ;   Lesser General Public License for more details.
0000             14   ;
0000             15   ;   You should have received a copy of the GNU Lesser General Public
0000             16   ;   License along with this library; if not, write to the Free Software
0000             17   ;   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
0000             18   ;
0000             19       
0000             20   P0     DATA  080H  ;PORT 0
0000             21   SP     DATA  081H  ;STACK POINTER
0000             22   DPL    DATA  082H  ;DATA POINTER 0 - LOW BYTE
0000             23   DPH    DATA  083H  ;DATA POINTER 0 - HIGH BYTE
0000             24   DPL1   DATA  084H  ;DATA POINTER 1 - LOW BYTE
0000             25   DPH1   DATA  085H  ;DATA POINTER 1 - HIGH BYTE
0000             26   DPS    DATA  086H  ;DATA POINTER SELECT. DPH1, DPL1 active when DPS.0=1
0000             27   PCON   DATA  087H  ;POWER CONTROL
0000             28   TCON   DATA  088H  ;TIMER CONTROL
0000             29   TMOD   DATA  089H  ;TIMER MODE
0000             30   TL0    DATA  08AH  ;TIMER 0 - LOW BYTE
0000             31   TL1    DATA  08BH  ;TIMER 1 - LOW BYTE
0000             32   TH0    DATA  08CH  ;TIMER 0 - HIGH BYTE
0000             33   TH1    DATA  08DH  ;TIMER 1 - HIGH BYTE
0000             34   P1     DATA  090H  ;PORT 1
0000             35   SCON   DATA  098H  ;SERIAL PORT CONTROL
0000             36   SBUF   DATA  099H  ;SERIAL PORT BUFFER
0000             37   P2     DATA  0A0H  ;PORT 2
0000             38   IE     DATA  0A8H  ;INTERRUPT ENABLE
0000             39   P3     DATA  0B0H  ;PORT 3
0000             40   IP     DATA  0B8H  ;INTERRUPT PRIORITY
0000             41   T2CON  DATA  0C8H  ;TIMER 2 CONTROL
0000             42   T2MOD  DATA  0C9H  ;TIMER 2 MODE
0000             43   RCAP2L DATA  0CAH  ;TIMER 2 CAPTURE REGISTER - LOW BYTE
0000             44   RCAP2H DATA  0CBH  ;TIMER 2 CAPTURE REGISTER - HIGH BYTE
0000             45   TL2    DATA  0CCH  ;TIMER 2 - LOW BYTE
0000             46   TH2    DATA  0CDH  ;TIMER 2 - HIGH BYTE
0000             47   PSW    DATA  0D0H  ;PROGRAM STATUS WORD
0000             48   ACC    DATA  0E0H  ;ACCUMULATOR
0000             49   B      DATA  0F0H  ;MULTIPLICATION REGISTER
0000             50   IT0    BIT   088H  ;TCON.0 - EXT. INTERRUPT 0 TYPE
0000             51   IE0    BIT   089H  ;TCON.1 - EXT. INTERRUPT 0 EDGE FLAG
0000             52   IT1    BIT   08AH  ;TCON.2 - EXT. INTERRUPT 1 TYPE
0000             53   IE1    BIT   08BH  ;TCON.3 - EXT. INTERRUPT 1 EDGE FLAG
0000             54   TR0    BIT   08CH  ;TCON.4 - TIMER 0 ON/OFF CONTROL
0000             55   TF0    BIT   08DH  ;TCON.5 - TIMER 0 OVERFLOW FLAG
0000             56   TR1    BIT   08EH  ;TCON.6 - TIMER 1 ON/OFF CONTROL
0000             57   TF1    BIT   08FH  ;TCON.7 - TIMER 1 OVERFLOW FLAG
0000             58   RI     BIT   098H  ;SCON.0 - RECEIVE INTERRUPT FLAG
0000             59   TI     BIT   099H  ;SCON.1 - TRANSMIT INTERRUPT FLAG
0000             60   RB8    BIT   09AH  ;SCON.2 - RECEIVE BIT 8
0000             61   TB8    BIT   09BH  ;SCON.3 - TRANSMIT BIT 8
0000             62   REN    BIT   09CH  ;SCON.4 - RECEIVE ENABLE
0000             63   SM2    BIT   09DH  ;SCON.5 - SERIAL MODE CONTROL BIT 2
0000             64   SM1    BIT   09EH  ;SCON.6 - SERIAL MODE CONTROL BIT 1
0000             65   SM0    BIT   09FH  ;SCON.7 - SERIAL MODE CONTROL BIT 0
0000             66   EX0    BIT   0A8H  ;IE.0 - EXTERNAL INTERRUPT 0 ENABLE
0000             67   ET0    BIT   0A9H  ;IE.1 - TIMER 0 INTERRUPT ENABLE
0000             68   EX1    BIT   0AAH  ;IE.2 - EXTERNAL INTERRUPT 1 ENABLE
0000             69   ET1    BIT   0ABH  ;IE.3 - TIMER 1 INTERRUPT ENABLE
0000             70   ES     BIT   0ACH  ;IE.4 - SERIAL PORT INTERRUPT ENABLE
0000             71   ET2    BIT   0ADH  ;IE.5 - TIMER 2 INTERRUPT ENABLE
0000             72   EA     BIT   0AFH  ;IE.7 - GLOBAL INTERRUPT ENABLE
0000             73   RXD    BIT   0B0H  ;P3.0 - SERIAL PORT RECEIVE INPUT
0000             74   TXD    BIT   0B1H  ;P3.1 - SERIAL PORT TRANSMIT OUTPUT
0000             75   INT0   BIT   0B2H  ;P3.2 - EXTERNAL INTERRUPT 0 INPUT
0000             76   INT1   BIT   0B3H  ;P3.3 - EXTERNAL INTERRUPT 1 INPUT
0000             77   T0     BIT   0B4H  ;P3.4 - TIMER 0 COUNT INPUT
0000             78   T1     BIT   0B5H  ;P3.5 - TIMER 1 COUNT INPUT
0000             79   WR     BIT   0B6H  ;P3.6 - WRITE CONTROL FOR EXT. MEMORY
0000             80   RD     BIT   0B7H  ;P3.7 - READ CONTROL FOR EXT. MEMORY
0000             81   PX0    BIT   0B8H  ;IP.0 - EXTERNAL INTERRUPT 0 PRIORITY
0000             82   PT0    BIT   0B9H  ;IP.1 - TIMER 0 PRIORITY
0000             83   PX1    BIT   0BAH  ;IP.2 - EXTERNAL INTERRUPT 1 PRIORITY
0000             84   PT1    BIT   0BBH  ;IP.3 - TIMER 1 PRIORITY
0000             85   PS     BIT   0BCH  ;IP.4 - SERIAL PORT PRIORITY
0000             86   PT2    BIT   0BDH  ;IP.5 - TIMER 2 PRIORITY
0000             87   CAP2   BIT   0C8H  ;T2CON.0 - CAPTURE OR RELOAD SELECT
0000             88   CNT2   BIT   0C9H  ;T2CON.1 - TIMER OR COUNTER SELECT
0000             89   TR2    BIT   0CAH  ;T2CON.2 - TIMER 2 ON/OFF CONTROL
0000             90   EXEN2  BIT   0CBH  ;T2CON.3 - TIMER 2 EXTERNAL ENABLE FLAG
0000             91   TCLK   BIT   0CCH  ;T2CON.4 - TRANSMIT CLOCK SELECT
0000             92   RCLK   BIT   0CDH  ;T2CON.5 - RECEIVE CLOCK SELECTT
0000             93   EXF2   BIT   0CEH  ;T2CON.6 - EXTERNAL TRANSITION FLAG
0000             94   TF2    BIT   0CFH  ;T2CON.7 - TIMER 2 OVERFLOW FLAG
0000             95   P      BIT   0D0H  ;PSW.0 - ACCUMULATOR PARITY FLAG
0000             96   OV     BIT   0D2H  ;PSW.2 - OVERFLOW FLAG
0000             97   RS0    BIT   0D3H  ;PSW.3 - REGISTER BANK SELECT 0
0000             98   RS1    BIT   0D4H  ;PSW.4 - REGISTER BANK SELECT 1
0000             99   F0     BIT   0D5H  ;PSW.5 - FLAG 0
0000            100   AC     BIT   0D6H  ;PSW.6 - AUXILIARY CARRY FLAG
0000            101   CY     BIT   0D7H  ;PSW.7 - CARRY FLAG
0000            102   
0000            103   ; For the altera DE2 configured with an 8051/8052 softcore processor
0000            104   ; we have the following extra registers:
0000            105   
0000            106   HEX0   DATA  091H ; Zero turns the segment on
0000            107   HEX1   DATA  092H ; 
0000            108   HEX2   DATA  093H ; 
0000            109   HEX3   DATA  094H ; 
0000            110   HEX4   DATA  08EH ;
0000            111   HEX5   DATA  08FH ;
0000            112   HEX6   DATA  096H ;
0000            113   HEX7   DATA  097H ;
0000            114   
0000            115   P0MOD  DATA  09AH ; Input/output mode bits for port 0.  '1' sets the port to output mode.
0000            116   P1MOD  DATA  09BH ; Input/output mode bits for port 1
0000            117   P2MOD  DATA  09CH ; Input/output mode bits for port 2
0000            118   P3MOD  DATA  09DH ; Input/output mode bits for port 3
0000            119   
0000            120   LEDRA  DATA  0E8H ; LEDs LEDR0 to LEDR7 (bit addressable, ex: LEDRA.1 for LEDR1)
0000            121   LEDRB  DATA  095H ; LEDs LEDR8 to LEDR15
0000            122   LEDRC  DATA  09EH ; LEDs LEDR16, LEDR15, and LEDG8
0000            123   LEDG   DATA  0F8H ; LEDs LEDG0 to LEDG7 (bit addressable, ex: LEDG.3 for LEDG3)
0000            124   SWA    DATA  0E8H ; Switches SW0 to SW7 (bit addressable, ex: SWA.1 for SW1)
0000            125   SWB    DATA  095H ; Switches SW8 to SW15
0000            126   SWC    DATA  09EH ; Switches SW16 and SW17
0000            127   KEY    DATA  0F8H ; KEY1=KEY.1, KEY2=KEY.2, KEY3=KEY.3.  KEY0 is the reset button! 
0000            128   
0000            129   LCD_CMD   DATA 0D8H ;
0000            130   LCD_DATA  DATA 0D9H ;
0000            131   LCD_MOD   DATA 0DAH ; Write 0xff to make LCD_DATA an output
0000            132   LCD_RW    BIT  0D8H ; '0' writes to LCD
0000            133   LCD_EN    BIT  0D9H ; Toggle from '1' to '0'
0000            134   LCD_RS    BIT  0DAH ; '0' for commands, '1' for data
0000            135   LCD_ON    BIT  0DBH ; Write '1' to power the LCD
0000            136   LCD_BLON  BIT  0DCH ; Write '1' to turn on back light
0000            137   
0000            138   FLASH_CMD  data 0DBH ; The control bits of the flash memory:
0000            139   ; bit 0: FL_RST_N  Set to 1 for normal operation
0000            140   ; bit 1: FL_WE_N
0000            141   ; bit 2: FL_OE_N
0000            142   ; bit 3: FL_CE_N
0000            143   FLASH_DATA data 0DCH ; 8-bit data bus of flash memory.
0000            144   FLASH_MOD  data 0DDH ; 0xff makes FLASH_DATA output.  0x00 makes FLASH_DATA input.
0000            145   FLASH_ADD0 data 0E1H ; address bits 0 to 7.
0000            146   FLASH_ADD1 data 0E2H ; address bits 8 to 15.
0000            147   FLASH_ADD2 data 0E3H ; address bits 16 to 21.
0000            148   
0000              2   
0000              3   org 0000H ; After reset, the processor starts at location zero
0000 02000C       4            ljmp main
0003              5   
0003              6   ;These three values are associated with the timing of the circuit
0003              7   ;Tune them to set the "heartbeat" of the program
0003              8   S_TICKS EQU #100
0003              9   M_TICKS EQU #100
0003             10   L_TICKS EQU #90
0003             11   
0003             12   ; Look-up table for my student number
0003             13   ; Least sig to most sig
0003             14   ; 48059760
0003             15   ; last one is just blank
0003             16   T_StuNum:
0003 40027810    17            DB 40H, 02H, 78H, 10H, 12H, 40H, 00H, 19H, 7FH
     12400019
     7F
000C             18   
                 19   Display_on mac
                 20   	mov b, a ; Preserve value of accumulator (just in case)
                 21   	
                 22   	mov dptr, #T_StuNum ; point to student number lookup table
                 23   	mov a, %1 ; Load macro's input into accumulator
                 24   	movc a, @dptr+a ; Read from table with the input offset
                 25   	
                 26   	mov %0, a ; Display number to given register
                 27   
                 28   	mov a, b ; Restore value of accumulator (just in case)
                 29   endmac
000C             30   
000C             31   main:
000C 75817F      32            mov SP, #0x7f
000F 75E800      33            mov LEDRA, #0 ; Bit addressable
0012 759500      34            mov LEDRB, #0 ; Not bit addressable
0015             35            
0015             36            ; Start timer
0015 7964        37            mov r1, S_TICKS
0017 7A64        38            mov r2, M_TICKS
0019 7B5A        39            mov r3, L_TICKS
001B             40            
001B             41            ; Mode 0 by default
001B F5F0        42            mov b, a ; Preserve value of accumulator (just in case)
001D             42            
001D 900003      42            mov dptr, #T_StuNum ; point to student number lookup table
0020 7402        42            mov a, #02 ; Load macro's input into accumulator
0022 93          42            movc a, @dptr+a ; Read from table with the input offset
0023             42            
0023 F591        42            mov HEX0, a ; Display number to given register
0025             42   
0025 E5F0        42            mov a, b ; Restore value of accumulator (just in case)
0027 F5F0        43            mov b, a ; Preserve value of accumulator (just in case)
0029             43            
0029 900003      43            mov dptr, #T_StuNum ; point to student number lookup table
002C 7403        43            mov a, #03 ; Load macro's input into accumulator
002E 93          43            movc a, @dptr+a ; Read from table with the input offset
002F             43            
002F F592        43            mov HEX1, a ; Display number to given register
0031             43   
0031 E5F0        43            mov a, b ; Restore value of accumulator (just in case)
0033 F5F0        44            mov b, a ; Preserve value of accumulator (just in case)
0035             44            
0035 900003      44            mov dptr, #T_StuNum ; point to student number lookup table
0038 7404        44            mov a, #04 ; Load macro's input into accumulator
003A 93          44            movc a, @dptr+a ; Read from table with the input offset
003B             44            
003B F593        44            mov HEX2, a ; Display number to given register
003D             44   
003D E5F0        44            mov a, b ; Restore value of accumulator (just in case)
003F F5F0        45            mov b, a ; Preserve value of accumulator (just in case)
0041             45            
0041 900003      45            mov dptr, #T_StuNum ; point to student number lookup table
0044 7405        45            mov a, #05 ; Load macro's input into accumulator
0046 93          45            movc a, @dptr+a ; Read from table with the input offset
0047             45            
0047 F594        45            mov HEX3, a ; Display number to given register
0049             45   
0049 E5F0        45            mov a, b ; Restore value of accumulator (just in case)
004B F5F0        46            mov b, a ; Preserve value of accumulator (just in case)
004D             46            
004D 900003      46            mov dptr, #T_StuNum ; point to student number lookup table
0050 7406        46            mov a, #06 ; Load macro's input into accumulator
0052 93          46            movc a, @dptr+a ; Read from table with the input offset
0053             46            
0053 F58E        46            mov HEX4, a ; Display number to given register
0055             46   
0055 E5F0        46            mov a, b ; Restore value of accumulator (just in case)
0057 F5F0        47            mov b, a ; Preserve value of accumulator (just in case)
0059             47            
0059 900003      47            mov dptr, #T_StuNum ; point to student number lookup table
005C 7407        47            mov a, #07 ; Load macro's input into accumulator
005E 93          47            movc a, @dptr+a ; Read from table with the input offset
005F             47            
005F F58F        47            mov HEX5, a ; Display number to given register
0061             47   
0061 E5F0        47            mov a, b ; Restore value of accumulator (just in case)
0063             48   Forever:
0063             49            ; Latching circuit
0063 20FB03      50            jb key.3, ENDLATCHtmp   ; jump if bit 3 of switch is = 1
0066 02006C      51            ljmp LATCHLOGIC
0069 02012E      52   ENDLATCHtmp: ljmp ENDLATCH       ; I have to do this weird jumping bc jb can only jump up to 127 lines
006C             53   
006C             54   LATCHLOGIC:
006C A8E8        55            mov r0, SWA                     ; store switch values in r0
006E             56            ; Evaluate initial load depending on switch value
006E E8          57            mov a, r0
006F 5407        58            ANL a, #07                              ; strip A to only the least significant 3 values
0071             59            
0071 B4004B      60            CJNE a, #00, MODE1              ; jump if A != byte
0074             61            ; Mode 0
0074 F5F0        62            mov b, a ; Preserve value of accumulator (just in case)
0076             62            
0076 900003      62            mov dptr, #T_StuNum ; point to student number lookup table
0079 7402        62            mov a, #02 ; Load macro's input into accumulator
007B 93          62            movc a, @dptr+a ; Read from table with the input offset
007C             62            
007C F591        62            mov HEX0, a ; Display number to given register
007E             62   
007E E5F0        62            mov a, b ; Restore value of accumulator (just in case)
0080 F5F0        63            mov b, a ; Preserve value of accumulator (just in case)
0082             63            
0082 900003      63            mov dptr, #T_StuNum ; point to student number lookup table
0085 7403        63            mov a, #03 ; Load macro's input into accumulator
0087 93          63            movc a, @dptr+a ; Read from table with the input offset
0088             63            
0088 F592        63            mov HEX1, a ; Display number to given register
008A             63   
008A E5F0        63            mov a, b ; Restore value of accumulator (just in case)
008C F5F0        64            mov b, a ; Preserve value of accumulator (just in case)
008E             64            
008E 900003      64            mov dptr, #T_StuNum ; point to student number lookup table
0091 7404        64            mov a, #04 ; Load macro's input into accumulator
0093 93          64            movc a, @dptr+a ; Read from table with the input offset
0094             64            
0094 F593        64            mov HEX2, a ; Display number to given register
0096             64   
0096 E5F0        64            mov a, b ; Restore value of accumulator (just in case)
0098 F5F0        65            mov b, a ; Preserve value of accumulator (just in case)
009A             65            
009A 900003      65            mov dptr, #T_StuNum ; point to student number lookup table
009D 7405        65            mov a, #05 ; Load macro's input into accumulator
009F 93          65            movc a, @dptr+a ; Read from table with the input offset
00A0             65            
00A0 F594        65            mov HEX3, a ; Display number to given register
00A2             65   
00A2 E5F0        65            mov a, b ; Restore value of accumulator (just in case)
00A4 F5F0        66            mov b, a ; Preserve value of accumulator (just in case)
00A6             66            
00A6 900003      66            mov dptr, #T_StuNum ; point to student number lookup table
00A9 7406        66            mov a, #06 ; Load macro's input into accumulator
00AB 93          66            movc a, @dptr+a ; Read from table with the input offset
00AC             66            
00AC F58E        66            mov HEX4, a ; Display number to given register
00AE             66   
00AE E5F0        66            mov a, b ; Restore value of accumulator (just in case)
00B0 F5F0        67            mov b, a ; Preserve value of accumulator (just in case)
00B2             67            
00B2 900003      67            mov dptr, #T_StuNum ; point to student number lookup table
00B5 7407        67            mov a, #07 ; Load macro's input into accumulator
00B7 93          67            movc a, @dptr+a ; Read from table with the input offset
00B8             67            
00B8 F58F        67            mov HEX5, a ; Display number to given register
00BA             67   
00BA E5F0        67            mov a, b ; Restore value of accumulator (just in case)
00BC             68            
00BC 02012E      69            ljmp ENDLATCH   
00BF B4014B      70   MODE1:   CJNE a, #01, MODE2              ; jump if A != byte 
00C2             71            ; Mode 1
00C2 F5F0        72            mov b, a ; Preserve value of accumulator (just in case)
00C4             72            
00C4 900003      72            mov dptr, #T_StuNum ; point to student number lookup table
00C7 7400        72            mov a, #00 ; Load macro's input into accumulator
00C9 93          72            movc a, @dptr+a ; Read from table with the input offset
00CA             72            
00CA F591        72            mov HEX0, a ; Display number to given register
00CC             72   
00CC E5F0        72            mov a, b ; Restore value of accumulator (just in case)
00CE F5F0        73            mov b, a ; Preserve value of accumulator (just in case)
00D0             73            
00D0 900003      73            mov dptr, #T_StuNum ; point to student number lookup table
00D3 7401        73            mov a, #01 ; Load macro's input into accumulator
00D5 93          73            movc a, @dptr+a ; Read from table with the input offset
00D6             73            
00D6 F592        73            mov HEX1, a ; Display number to given register
00D8             73   
00D8 E5F0        73            mov a, b ; Restore value of accumulator (just in case)
00DA F5F0        74            mov b, a ; Preserve value of accumulator (just in case)
00DC             74            
00DC 900003      74            mov dptr, #T_StuNum ; point to student number lookup table
00DF 7408        74            mov a, #08 ; Load macro's input into accumulator
00E1 93          74            movc a, @dptr+a ; Read from table with the input offset
00E2             74            
00E2 F593        74            mov HEX2, a ; Display number to given register
00E4             74   
00E4 E5F0        74            mov a, b ; Restore value of accumulator (just in case)
00E6 F5F0        75            mov b, a ; Preserve value of accumulator (just in case)
00E8             75            
00E8 900003      75            mov dptr, #T_StuNum ; point to student number lookup table
00EB 7408        75            mov a, #08 ; Load macro's input into accumulator
00ED 93          75            movc a, @dptr+a ; Read from table with the input offset
00EE             75            
00EE F594        75            mov HEX3, a ; Display number to given register
00F0             75   
00F0 E5F0        75            mov a, b ; Restore value of accumulator (just in case)
00F2 F5F0        76            mov b, a ; Preserve value of accumulator (just in case)
00F4             76            
00F4 900003      76            mov dptr, #T_StuNum ; point to student number lookup table
00F7 7408        76            mov a, #08 ; Load macro's input into accumulator
00F9 93          76            movc a, @dptr+a ; Read from table with the input offset
00FA             76            
00FA F58E        76            mov HEX4, a ; Display number to given register
00FC             76   
00FC E5F0        76            mov a, b ; Restore value of accumulator (just in case)
00FE F5F0        77            mov b, a ; Preserve value of accumulator (just in case)
0100             77            
0100 900003      77            mov dptr, #T_StuNum ; point to student number lookup table
0103 7408        77            mov a, #08 ; Load macro's input into accumulator
0105 93          77            movc a, @dptr+a ; Read from table with the input offset
0106             77            
0106 F58F        77            mov HEX5, a ; Display number to given register
0108             77   
0108 E5F0        77            mov a, b ; Restore value of accumulator (just in case)
010A             78                    
010A 02012E      79            ljmp ENDLATCH
010D B40203      80   MODE2:   CJNE a, #02, MODE3              ; jump if A != byte 
0110             81            ; Mode 2
0110             82            
0110             83            
0110 02012E      84            ljmp ENDLATCH
0113 B40303      85   MODE3:   CJNE a, #03, MODE4              ; jump if A != byte 
0116             86            ; Mode 3
0116             87            
0116             88            
0116 02012E      89            ljmp ENDLATCH
0119 B40403      90   MODE4:   CJNE a, #04, MODE5              ; jump if A != byte 
011C             91            ; Mode 4
011C             92            
011C             93            
011C 02012E      94            ljmp ENDLATCH
011F B40503      95   MODE5:   CJNE a, #05, MODE6              ; jump if A != byte 
0122             96            ; Mode 5
0122             97            
0122             98            
0122 02012E      99            ljmp ENDLATCH
0125 B40603     100   MODE6:   CJNE a, #06, MODE7              ; jump if A != byte 
0128            101            ; Mode 6
0128            102            
0128            103            
0128 02012E     104            ljmp ENDLATCH
012B            105   MODE7:   ; this should be the "else" case
012B            106            ; Mode 7
012B            107            
012B            108            
012B 02012E     109            ljmp ENDLATCH   
012E            110   ENDLATCH: 
012E            111            
012E            112            ; Timing circuit
012E D90C       113            djnz r1, ENDTIME
0130 7964       114            mov r1, S_TICKS         ; if we got here, that means r1 is zero
0132 DA08       115            djnz r2, ENDTIME
0134 7A64       116            mov r2, M_TICKS         ; if we got here, that means r2 is zero
0136 DB04       117            djnz r3, ENDTIME
0138 7B5A       118            mov r3, L_TICKS         ; if we got here, that means r3 is zero
013A            119            
013A            120            
013A            121            ; these lines executes once a "heartbeat"
013A B2E8       122            cpl LEDRA.0             ;flip LED to visualize heartbeat
013C            123            
013C            124   ENDTIME:
013C            125   
013C 020063     126            ljmp Forever ; Repeat forever
013F            127   END
